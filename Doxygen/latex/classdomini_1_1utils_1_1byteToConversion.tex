\hypertarget{classdomini_1_1utils_1_1byteToConversion}{}\section{domini.\+utils.\+byte\+To\+Conversion Class Reference}
\label{classdomini_1_1utils_1_1byteToConversion}\index{domini.\+utils.\+byte\+To\+Conversion@{domini.\+utils.\+byte\+To\+Conversion}}


Classe \hyperlink{classdomini_1_1utils_1_1byteToConversion}{byte\+To\+Conversion}.  


\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static Character \hyperlink{classdomini_1_1utils_1_1byteToConversion_a5d2f5f8de52e4001cf6698ca03fe31e8}{byte\+To\+Character} (Byte b)
\begin{DoxyCompactList}\small\item\em Transforma un byte a Character. \end{DoxyCompactList}\item 
static Integer \hyperlink{classdomini_1_1utils_1_1byteToConversion_a3242a47adade49b6cfa6a9232944f587}{byte\+To\+Integer} (List$<$ Byte $>$ b\+Arg)
\begin{DoxyCompactList}\small\item\em Transforma un Array de bytes a un Enter no negatiu. \end{DoxyCompactList}\item 
static Long \hyperlink{classdomini_1_1utils_1_1byteToConversion_a18600284c32cae9284c16c6396425d5a}{byte\+To\+Long} (List$<$ Byte $>$ b\+Arg)
\begin{DoxyCompactList}\small\item\em Transforma un Array de bytes a un long no negatiu. \end{DoxyCompactList}\item 
static Array\+List$<$ Byte $>$ \hyperlink{classdomini_1_1utils_1_1byteToConversion_ab4466a4c6dd5f6a350953031e99a959d}{long\+To\+Byte} (long x)
\begin{DoxyCompactList}\small\item\em Transforma un long a un array de 8 bytes en big endian. \end{DoxyCompactList}\item 
static byte \hyperlink{classdomini_1_1utils_1_1byteToConversion_a0e232cb9d272ccc13accda58bab9f8e1}{shift\+\_\+right\+\_\+logic} (byte b, int despl)
\begin{DoxyCompactList}\small\item\em Desplaçament lògic cap a la detra d\textquotesingle{}un byte. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Classe \hyperlink{classdomini_1_1utils_1_1byteToConversion}{byte\+To\+Conversion}. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classdomini_1_1utils_1_1byteToConversion_a5d2f5f8de52e4001cf6698ca03fe31e8}\label{classdomini_1_1utils_1_1byteToConversion_a5d2f5f8de52e4001cf6698ca03fe31e8}} 
\index{domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}!byte\+To\+Character@{byte\+To\+Character}}
\index{byte\+To\+Character@{byte\+To\+Character}!domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}}
\subsubsection{\texorpdfstring{byte\+To\+Character()}{byteToCharacter()}}
{\footnotesize\ttfamily public static Character domini.\+utils.\+byte\+To\+Conversion.\+byte\+To\+Character (\begin{DoxyParamCaption}\item[{Byte}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Transforma un byte a Character. 


\begin{DoxyParams}{Parameters}
{\em b} & Byte a transformar \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Character resultat de la transformació 
\end{DoxyReturn}

\begin{DoxyCode}
22     \{
23         Character ret;
24 
25         ret = (char)b.byteValue();
26 
27         \textcolor{keywordflow}{return} ret;
28     \}
\end{DoxyCode}
\mbox{\Hypertarget{classdomini_1_1utils_1_1byteToConversion_a3242a47adade49b6cfa6a9232944f587}\label{classdomini_1_1utils_1_1byteToConversion_a3242a47adade49b6cfa6a9232944f587}} 
\index{domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}!byte\+To\+Integer@{byte\+To\+Integer}}
\index{byte\+To\+Integer@{byte\+To\+Integer}!domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}}
\subsubsection{\texorpdfstring{byte\+To\+Integer()}{byteToInteger()}}
{\footnotesize\ttfamily public static Integer domini.\+utils.\+byte\+To\+Conversion.\+byte\+To\+Integer (\begin{DoxyParamCaption}\item[{List$<$ Byte $>$}]{b\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Transforma un Array de bytes a un Enter no negatiu. 


\begin{DoxyParams}{Parameters}
{\em b\+Arg} & Llista de bytes que volem transformar (de més a menys significatius, aka big endian) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Integer resultat de la conversió 
\end{DoxyReturn}

\begin{DoxyCode}
37     \{
38         Integer ret = 0;
39 
40         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < bArg.size(); i++)
41         \{
42             Byte b = bArg.get(i);
43             
44             ret += ( (b&0xFF) << (8*(bArg.size() - i -1)) );
45         \}
46         \textcolor{keywordflow}{return} ret;
47     \}
\end{DoxyCode}
\mbox{\Hypertarget{classdomini_1_1utils_1_1byteToConversion_a18600284c32cae9284c16c6396425d5a}\label{classdomini_1_1utils_1_1byteToConversion_a18600284c32cae9284c16c6396425d5a}} 
\index{domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}!byte\+To\+Long@{byte\+To\+Long}}
\index{byte\+To\+Long@{byte\+To\+Long}!domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}}
\subsubsection{\texorpdfstring{byte\+To\+Long()}{byteToLong()}}
{\footnotesize\ttfamily public static long domini.\+utils.\+byte\+To\+Conversion.\+byte\+To\+Long (\begin{DoxyParamCaption}\item[{List$<$ Byte $>$}]{b\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Transforma un Array de bytes a un long no negatiu. 


\begin{DoxyParams}{Parameters}
{\em b\+Arg} & Llista de bytes que volem transformar (de més a menys significatius, aka big endian) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
long resultat de la conversió 
\end{DoxyReturn}

\begin{DoxyCode}
56     \{
57         Long ret = (long)0;
58 
59         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < bArg.size(); i++)
60         \{
61             Byte b = bArg.get(i);
62             
63             ret += ( (long)(b&0xFF) << (8*(bArg.size() - i -1)) );
64         \}
65         \textcolor{keywordflow}{return} ret;
66     \}
\end{DoxyCode}
\mbox{\Hypertarget{classdomini_1_1utils_1_1byteToConversion_ab4466a4c6dd5f6a350953031e99a959d}\label{classdomini_1_1utils_1_1byteToConversion_ab4466a4c6dd5f6a350953031e99a959d}} 
\index{domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}!long\+To\+Byte@{long\+To\+Byte}}
\index{long\+To\+Byte@{long\+To\+Byte}!domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}}
\subsubsection{\texorpdfstring{long\+To\+Byte()}{longToByte()}}
{\footnotesize\ttfamily public static Array\+List$<$ Byte $>$ domini.\+utils.\+byte\+To\+Conversion.\+long\+To\+Byte (\begin{DoxyParamCaption}\item[{long}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Transforma un long a un array de 8 bytes en big endian. 


\begin{DoxyParams}{Parameters}
{\em x} & El long que volem transformar \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
L\textquotesingle{}array de bytes resultant (de més a menys significatius, aka big endian) 
\end{DoxyReturn}

\begin{DoxyCode}
75     \{
76 
77         ArrayList<Byte> al = \textcolor{keyword}{new} ArrayList<>();
78         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 7; i >= 0; i--)
79         \{
80             al.add(0, (byte)x);
81             x = (x >> 8);  
82         \}
83         \textcolor{keywordflow}{return} al;
84     \}
\end{DoxyCode}
\mbox{\Hypertarget{classdomini_1_1utils_1_1byteToConversion_a0e232cb9d272ccc13accda58bab9f8e1}\label{classdomini_1_1utils_1_1byteToConversion_a0e232cb9d272ccc13accda58bab9f8e1}} 
\index{domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}!shift\+\_\+right\+\_\+logic@{shift\+\_\+right\+\_\+logic}}
\index{shift\+\_\+right\+\_\+logic@{shift\+\_\+right\+\_\+logic}!domini\+::utils\+::byte\+To\+Conversion@{domini\+::utils\+::byte\+To\+Conversion}}
\subsubsection{\texorpdfstring{shift\+\_\+right\+\_\+logic()}{shift\_right\_logic()}}
{\footnotesize\ttfamily public static byte domini.\+utils.\+byte\+To\+Conversion.\+shift\+\_\+right\+\_\+logic (\begin{DoxyParamCaption}\item[{byte}]{b,  }\item[{int}]{despl }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Desplaçament lògic cap a la detra d\textquotesingle{}un byte. 


\begin{DoxyParams}{Parameters}
{\em b} & Byte que volem desplaçar \\
\hline
{\em despl} & Nombre de bits que volem desplaçar \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Byte desplaçat 
\end{DoxyReturn}

\begin{DoxyCode}
93                                                             \{
94         \textcolor{keywordflow}{return} (byte) ((byte) (b >>> despl) &~ (byte) (0xff << (8-despl)));
95     \}
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/domini/utils/\hyperlink{byteToConversion_8java}{byte\+To\+Conversion.\+java}\end{DoxyCompactItemize}
